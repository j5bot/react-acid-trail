<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: acid-trail/NTC.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: acid-trail/NTC.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { shades, names } from './colors';

/**
 * Function which returns an object containing properties representing a named
 * color which has most closely matched a given RGB hex color which was provided
 * to the {@link name} function.
 *
 * The properties are:
 *
 * - color: the RGB hex color corresponding to the closest match in the format
 * '#RRGGBB'.
 * - name: the name of the color corresponding to the closest match
 * - shade: the RGB hex value of the shade corresponding to the closest match.
 * Shades are the basic colors such as 'red', 'yellow', 'blue', etc.  In the
 * format 'RRGGBB'.
 * - shadeName: the name of the shade corresponding to the closest match.
 * - exact: a boolean value indicating whether the closest match is an exact
 * match.
 *
 * @param  {Array} name     An array containing properties of a named color
 * @param  {Boolean} exact  Boolean indicating whether the match is exact
 * @return {Object}         An object describing a match found by
 * {@link name}
 */
export const colormatch = (name, exact) => {
  return {
    color:     '#' + name[0],
    name:      name[1],
    shade:     shadergb(name[2]),
    shadeName: name[2],
    exact:     exact
  };
};

/**
 * Function which initializes a named color set represented as an array of
 * colors represented as arrays containing:
 * - Hex RGB color [0]
 * - Color name [1]
 * - Color shade name [2]

 * Colors are initialized by adding individual R,G,B and H,S,L values as needed.

 * @return {Array} An array of colors represented as arrays containing:
 * - Hex RGB color [0]
 * - Color name [1]
 * - Color shade name [2]
 * - Red value [3]
 * - Green value [4]
 * - Blue value [5]
 * - Hue value [6]
 * - Saturation value [7]
 * - Lightness value [8]
 */
export const init = (names) => {
  return names.map(
    (name) => {
      const color = name[0];

      // handle error cases
      if (name.length === 1) {
        name.push('NO COLOR NAME');
      }
      if (name.length === 2) {
        name.push('NO SHADE NAME');
      }
      // add rgb as needed
      if (name.length &lt; 6) {
        name = name.slice(2).concat(rgb(color));
      }
      // add hsl as needed
      if (name.length &lt; 9) {
        name = name.slice(5).concat(hsl(color));
      }

      return name;
    }
  );
};

/**
 * In-place sort of the provided 'names' array by RGB and HSL values
 * @return {Array} The provided 'names' sorted by RGB and HSL values
 */
export const sort = (names) => {
  names.sort(
    (aaa, bbb) => {
      for (let i = 3; i &lt; 9; i++) {
        if (aaa[i] !== bbb[i]) {
          return aaa[i] - bbb[i];
        }
      }
      return 0;
    }
  );

  return names;
};

/**
 * Return the HSL values as an array, given the RGB hex color.
 * taken from https://github.com/eligrey/color.js (MIT License)
 *
 * @param  {String} color String representation of an RGB hex color value.
 * @return {Array}        An array containing hue, saturation, and lightness
 *                        values as integers.
 */
export const hsl = (color) => {

  var rgb = rgb(color);
  var red = rgb[0],
      green = rgb[1],
      blue = rgb[2];

  red /= 255;
  green /= 255;
  blue /= 255;

  var max = Math.max(red, green, blue),
      min = Math.min(red, green, blue),
      hue,
      sat,
      light = (max + min) / 2;

  if (max === min) {
    hue = sat = 0; // achromatic
  } else {
    const diff = max - min;

    sat = light > 0.5 ? diff / (2 - max - min) : diff / (max + min);
    switch (max) {
    case red: hue = (green - blue) / diff + (green &lt; blue ? 6 : 0); break;
    case green: hue = (blue - red) / diff + 2; break;
    case blue: hue = (red - green) / diff + 4; break;
    }
    hue /= 6;
  }

  return [ hue * 255, sat * 255, light * 255 ];
};

/**
 * Return the RGB values as decimal integers, given a string RGB hex value.
 *
 * @param  {String} color A String representation of an RGB hex color value.
 * @return {Array}        An array containing R,G,B values as decimal integers.
 */
export const rgb = (color) => {
  return [
    parseInt(color.substr(0, 2), 16),
    parseInt(color.substr(2, 2), 16),
    parseInt(color.substr(4, 2), 16)
  ];
};

/**
 * Given the color shade name as a string, such as 'Red', return the string RGB
 * hex color value in the format '#RRGGBB'.
 *
 * If no match is found, return '#000000' (black).
 *
 * @param  {String} shadename Descriptive name of the color shade.
 * @return {String}           String RGB hex color value in the format
 *                            '#RRGGBB'.
 */
export const shadergb = (shadename) => {
  // return the first matching shade's RGB value, or the default
  return shades
    // filter matching shades
    .filter(
      (shade) => shadename === shade[1]
    )
    // get only the RGB value of the matching shades
    .map(
      (shade) => `#${shade[0]}`
    )
    // add a default RGB value
    // and get the first value in the array
    .concat('#000000')[0];

};

export const cleanColor = (color) => {
  if (typeof color !== 'string') {
    return false;
  }
  // take the first 1-6 hex characters and uppercase them,
  // discarding prefix, suffix, etc.
  color = color.replace(/.*([0-f]{1,6}).*/ig, '$1').toUpperCase();

  // for color lengths less than 6, change RGB* to RRGGBB
  color = color.length === 6 ?
    color :
    (
      color.length >= 3 ?
        color.replace(/(.{1})(.{1})(.{1})/ig, '$1$1$2$2$3$3') :
        false
    );

  return color;
};

/**
 * Return an object representing an invalid color match
 * @return {Object} See {@link colormatch}
 */
const createInvalidMatch = () => {
  return colormatch(
    [ '000000', 'Invalid Color Name', 'Invalid' ]
  );
};

/**
 * Get the difference between the color and the named color as the combined
 * RGB or HSL difference.
 *
 * @param  {Array} color  Color value as three-part array
 * @param  {Array} name   Named color value as three-part array
 * @return {Integer}      The difference in value as the combined difference
 *                        of each part.
 */
const getColorDiff = ({ color, name }) => {
  const getPartDiff = createGetPartDiff(color, name);

  // red + green + blue or hue + sat + light
  return getPartDiff(1) + getPartDiff(2) + getPartDiff(3);
};

/**
 * Create a function to get the difference between color and named color part
 *
 * @param  {Array} color    Color value as three-part array
 * @param  {Array} name     Named color value as three-part array
 * @return {Function}       A function which computes the square of the
 *                          difference between the parts
 */
const createGetPartDiff = (color, name) =>
  (part) => {
    return Math.pow(
      color[part] - name[part],
      2
    );
  };

/**
 * Return a named color 'colormatch' for the given RGB hex color value.

 * @param  {String} color String RGB hex color value in either the format of
 *                        '#RRGGBB' or 'RRGGBB'
 * @return {[type]}       [description]
 */
export const match = (color) => {
  // trim before first occurence of # and use upper case
  color = cleanColor(color);

  if (!color) {
    return createInvalidMatch();
  }

  let newDiff,
      exact = false,
      closest = names[0], // assume that black is the closest, maybe?
      diff = Number.POSITIVE_INFINITY; // really big difference, right?

  names.every(
    (named) => {
      // if the match is exact, return immediately and don't check more
      if (color === named[0]) {
        closest = named;
        exact = true;
      } else {
        // rgb + hsl difference score
        newDiff = getColorDiff(
          rgb(color),
          named.slice(3, 5)
        ) + getColorDiff(
          hsl(color),
          named.slice(6, 8)
        ) * 2;

        // if this is closer, change the closest color
        if (diff > newDiff) {
          diff = newDiff;
          closest = named;
        }
      }
      return exact;
    }
  );

  return colormatch(closest, exact);
};

export default {
  shades,
  names,
  init,
  sort,
  match
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ConstructedWorker.html">ConstructedWorker</a></li><li><a href="HasherWorker.html">HasherWorker</a></li><li><a href="WorkerHasher.html">WorkerHasher</a></li></ul><h3>Global</h3><ul><li><a href="global.html#colormatch">colormatch</a></li><li><a href="global.html#createGetPartDiff">createGetPartDiff</a></li><li><a href="global.html#createInvalidMatch">createInvalidMatch</a></li><li><a href="global.html#getColorDiff">getColorDiff</a></li><li><a href="global.html#hsl">hsl</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#match">match</a></li><li><a href="global.html#rgb">rgb</a></li><li><a href="global.html#shadergb">shadergb</a></li><li><a href="global.html#sort">sort</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Oct 29 2018 15:20:40 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
